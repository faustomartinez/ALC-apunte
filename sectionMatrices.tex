\section{Operaciones con matrices}

\subsection{Multiplicación de matrices}

Dadas matrices $A \in \K^{m \times n}$ y $B \in \K^{n \times p}$

$$
\Ab =\begin{pmatrix}a_{11}&a_{12}&\cdots &a_{1n}\\a_{21}&a_{22}&\cdots &a_{2n}\\\vdots &\vdots &\ddots &\vdots \\a_{m1}&a_{m2}&\cdots &a_{mn}\\\end{pmatrix},\quad  {\Bb} ={\begin{pmatrix}b_{11}&b_{12}&\cdots &b_{1p}\\b_{21}&b_{22}&\cdots &b_{2p}\\\vdots &\vdots &\ddots &\vdots \\b_{n1}&b_{n2}&\cdots &b_{np}\\\end{pmatrix}}
$$ el producto $\Cb = \Ab\Bb$ es la matriz de $m$ filas y $p$ columnas

$$
\Cb =\begin{pmatrix}c_{11}&c_{12}&\cdots &c_{1p}\\c_{21}&c_{22}&\cdots &c_{2p}\\\vdots &\vdots &\ddots &\vdots \\c_{m1}&c_{m2}&\cdots &c_{mp}\\\end{pmatrix} \in \K^{m \times p},
$$
con
$$
c_{ij}=a_{i1}b_{1j}+a_{i2}b_{2j}+\cdots +a_{in}b_{nj}=\sum _{k=1}^{n}a_{ik}b_{kj}
$$
(en la casilla $(i,j)$ de $\Cb$ ponemos el producto de la fila $i$ de $\Ab$ con la columna $j$ de $\Bb$) .


Si multiplicamos dos matrices o vectores en \python con $*$ ...

\begin{Shaded}
\begin{lstlisting}[language=Python]
A1 = np.array([[1,2],[3,4]])
A2 = np.array([[1,0],[0,1]])
print(A1)
print(A2)
print(A1 * A2)
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
%% A1 =
%%  [[1 2]
%%  [3 4]]
%% A2 =
%%  [[1 0]
%%  [0 1]]
%% A1 * A2 =
%%  [[1 0]
%%  [0 4]]
\end{verbatim}

La operación $*$ en \python calcula el producto coordenada a coordenada. Esta operación se llama producto de Hadamard, y es útil en muchos casos, pero no es el producto usual de matrices.

Para el producto usual de matrices usamos en Python el símbolo @.

\begin{Shaded}
\begin{lstlisting}[language=Python]
print("A1 @ A2 = \n", A1 @ A2)   # Producto usual de matrices
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
%% A1 @ A2 =
%%  [[1 2]
%%  [3 4]]
\end{verbatim}

¡Revisar siempre que estemos usando el producto correcto en \python!

\begin{ejercicio} \label{ejer:productos}
Realizar (a mano) los siguientes productos de matrices:
\begin{enumerate}
\item  $\begin{pmatrix}3&5\\ 2 & -9 \end{pmatrix} \cdot \begin{pmatrix}1&-1\\ 0 & 2 \end{pmatrix}$
\item  $\begin{pmatrix}3&5\end{pmatrix} \cdot \begin{pmatrix}4\\ -3\end{pmatrix}$
\item  $\begin{pmatrix}4\\ -3\end{pmatrix} \cdot \begin{pmatrix}3&5\end{pmatrix}$
\item \label{item:sistema}  $\begin{pmatrix}3&5\\ 2 & -9 \end{pmatrix} \cdot \begin{pmatrix}x\\ y \end{pmatrix}$
\end{enumerate}
\end{ejercicio}

\textbf{Observaciones:}

\begin{itemize}
\item El producto de matrices es asociativo. Es decir $\Ab(\Bb\Cb) = (\Ab\Bb)\Cb$, para matrices con los tamaños apropiados para realizar los productos.
\item El producto de matrices no es conmutativo. En general, no vale $\Ab \Bb = \Bb \Ab$, ni siquiera en el caso de matrices cuadradas. Lo verificamos en \python.
\end{itemize}

\begin{Shaded}
\begin{lstlisting}[language=Python]
A = np.array([[1, 2], [2, 3]])
B = np.array([[2, 5], [1, 4]])
print("A @ B = \n", A @ B)
print("B @ A = \n", B @ A)
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
A @ B =
 [[ 4 13]
 [ 7 22]]
B @ A =
 [[12 19]
 [ 9 14]]
\end{verbatim}

\begin{itemize}
\item Si bien vimos que el conjunto de matrices $\K^{m \times n}$ es un espacio vectorial, el producto de matrices no es una operación de espacio vectorial.
\end{itemize}

\subsection{Matrices transpuesta y conjugada}

La matriz transpuesta de $\Ab = (a_{ij}) \in {\R^{m \times n}}$ es la matriz que se obtienen a partir de $\Ab$ intercambiando filas por columnas, es decir $\Ab^T = (a_{ji}) \in \R^{n \times m}$.

\begin{ejemplo}\leavevmode
\begin{itemize}
\item Si $\Ab =\begin{pmatrix}a_{11}&a_{12}&a_{13} \\ a_{21}&a_{22}&a_{23}\end{pmatrix}$ , $\Ab^T = \begin{pmatrix}a_{11}&a_{21}\\a_{12} & a_{22} \\ a_{13} & a_{23}\end{pmatrix}$.
\item Si $\Ab =\begin{pmatrix}5&7 \\ 3&-1\end{pmatrix}$ , $\Ab^T = \begin{pmatrix}5&3\\7 & -1 \end{pmatrix}$.
\end{itemize}
\end{ejemplo}

\begin{proposicion}\leavevmode
\begin{itemize}
\item $(\Ab^T)^T = \Ab$.
\item $(\Ab \Bb)^T = \Bb^T \Ab^T$.
\end{itemize}
\end{proposicion}

En \python calculamos la transpuesta de una matriz con el comando \texttt{transpose} de \texttt{numpy}.

\begin{Shaded}
\begin{lstlisting}[language=Python]
A = np.array([[5,7],[3,-1]])
print(np.transpose(A))
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
## [[ 5  3]
##  [ 7 -1]]
\end{verbatim}

En lo que sigue resulta de utilidad definir lo siguiente: consideremos $\vb\in \Kn$, $\Ab\in \Knn$, con $\overline{\vb}\in \Kn$ (resp. $\overline{\Ab}\in \Knn$), denotamos el vector (resp. matrix) que tiene los mismos elementos que $\vb$ (resp. $\Ab$) pero conjugados. Obviamente si $\K=\R$, $\overline{\vb}=\vb$,  $\overline{\Ab}=\Ab$.

La siguiente definición generaliza a la traspuesta en las matrices y a la conjugación en los escalares.

Dada $\Ab\in \K^{n\times m}$, la \emph{matriz conjugada} de $\Ab$, denotada con $\Ab^*$
 se define como $\Ab^*=\overline{\Ab^T}$.

Notar que si $a\in \K^{1\times 1}$ ( o sea, es un escalar, $a\in \K$) entonces $a^*=\overline{a}$. La conjugación hereda las propiedades de la traspuesta:
\begin{itemize}
 \item $(\Ab^*)^*=\Ab$
 \item Si $\K=\R$, $\Ab^*=\Ab^T$.
 \item $(\Ab\Bb)^*=\Bb^*\Ab^*$
 \item $(a\Ab+b\Bb)^*=\overline{a}\Ab^*+ \overline{b}\Bb^*$.
\end{itemize}




\subsection{Sistemas lineales y ecuaciones matriciales}

Observando el producto del punto \ref{item:sistema} del Ejercicio \ref{ejer:productos}, vemos que podemos plantear el sistema de ecuaciones lineales

$$
\left\{ {\begin{alignedat}{5}3x&&\;+\;&&5y&&\;=\;&&4&\\2x&&\;-\;&&9y&&\;=\;&&15&.\end{alignedat}} \right.
$$
en forma matricial
$$\begin{pmatrix}3&5\\ 2 & -9 \end{pmatrix} \cdot \begin{pmatrix}x\\ y \end{pmatrix} = \begin{pmatrix}4\\ 15 \end{pmatrix},$$
o en general, $\Ab \xb = \bb$, donde $\Ab \in \mathbb{R}^{m \times n}$ es la matriz de coeficientes, $\xb$ es un vector o matriz columna de incógnitas y $\bb \in \mathbb{R}^{n}$ es el vector de términos constantes.

\textbf{Pregunta:} ¿cuántas incógnitas y cuántas ecuaciones tiene el sistema $\Ab \xb = \bb$ con los tamaños dados?

Para resolver sistemas de ecuaciones en \python podemos usar el comando \texttt{solve} (vamos a volver a esto más adelante).

\begin{Shaded}
\begin{lstlisting}[language=Python]
A = np.array([[3,2],[5,-4]])
b = np.array([22, -11])
print(np.linalg.solve(A, b))
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
## [3.  6.5]
\end{verbatim}

\subsection{Rango de una matriz}

Para saber si un sistema de ecuaciones puede tener solución única, infinitas soluciones o ninguna solución, calculamos el \emph{rango} de la matriz $A$. Pensando las filas de una matriz como ecuaciones, el rango de la matriz nos indica cuantas ecuaciones "independientes" tenemos.

El rango de una matriz es la máxima cantidad de filas o columnas linealmente independientes que posee la matriz.

\begin{proposicion} La máxima cantidad de filas linealmente independientes de una matriz coincide con la máxima cantidad de columnas linealmente independientes.
\end{proposicion}

Por lo tanto, no es necesario distinguir rango-fila de rango-columna, y hablamos simplemente de \emph{rango}.

\begin{ejemplo}\leavevmode
\begin{enumerate}
\item $\rank\left(\begin{pmatrix}1&4&7\\0&2&6\end{pmatrix}\right) = 2$
\item $\rank\left(\begin{pmatrix}1&0&1 \\ 0&1&2 \\ 1 & 2 & 5\end{pmatrix}\right) = 1$
\end{enumerate}
\end{ejemplo}

\subsubsection{¿Cómo calcular el rango?}

Para calcular el rango de una matriz, triangulamos la matriz y contamos cuántas filas no nulas quedan.

\begin{proposicion}
El espacio vectorial generado por las filas de una matriz antes o después de triangular es el mismo.
\end{proposicion}

En \python, calculamos el rango de una matriz con el comando \texttt{matrix\_rank} de \texttt{numpy.linalg}.

\begin{Shaded}
\begin{lstlisting}[language=Python]
A = np.array([[1,0,1],[0,1,2],[1,2,5]])
print("Rango de A = ", np.linalg.matrix_rank(A))

B = np.array([[1,2,3],[4,5,6],[7,8,9]])
print("Rango de B = ", np.linalg.matrix_rank(B))
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
## Rango de A =  2
## Rango de B =  2
\end{verbatim}

\subsubsection{Sistemas de ecuaciones y rango de matrices}

Si $\rank(\Ab)$ es igual a la cantidad de filas, el sistema $\Ab \xb = \bb$ siempre tiene solución. Todas las ecuaciones son independientes entre sí.

Si la matriz $\Ab$ es cuadrada y $\rank(\Ab)$ es igual a la cantidad de filas, decimos que $\Ab$ tiene rango máximo. En este caso, el sistema $\Ab \xb = \bb$ tiene solución única para todo $\bb$.

\subsubsection{Rango de un producto de matrices}

Dadas matrices $\Ab \in \mathbb{R}^{m \times n}$ y $\Bb \in \mathbb{R}^{n \times p}$,

\begin{enumerate}
\item  $\rank(\Ab) = \rank(\Ab^T) = \rank(\Ab^T\Ab) = \rank(\Ab\Ab^T)$
\item  $\rank(\Ab \Bb) \le \min\{\rank(\Ab), \rank(\Bb)\}$.
\item  Si $\rank(\Bb) = n$, entonces $\rank(\Ab \Bb) = \rank(\Ab)$.
\item  Si $\Bb \in \R^{n \times n}$, y $\Bb$ tiene rango máximo, entonces $\rank(\Ab \Bb) = \rank(\Ab)$.
\end{enumerate}

Idea de las demostración: las filas de $\Ab \Bb$ son combinaciones de las filas de $\Bb$ y las columnas de $\Ab\Bb$ son combinaciones de las columnas de $\Ab$.


\subsection{Matrices especiales}

\subsubsection{Matriz diagonal}

Una matriz $\Ab \in \R^{n \times n}$ se dice diagonal si $a_{ij} = 0$ para todo $i \neq j$, es decir:

$$
\Ab =\begin{pmatrix}a_{11}&0&\cdots &0\\0&a_{22}&\cdots &0\\\vdots &\vdots &\ddots &\vdots \\0&0&\cdots &a_{nn}\\\end{pmatrix}
$$

\begin{ejercicio} Calcular a mano pero sin hacer muchas cuentas:
\begin{enumerate}
\item   $\begin{pmatrix}1&0&0 \\ 0&2&0 \\ 0& 0 & 3\end{pmatrix}^3$,
\item   $\begin{pmatrix}1&0&0 \\ 0&2&0 \\ 0& 0 & 3\end{pmatrix} \cdot \begin{pmatrix}1&1&1 \\ 2&2&2 \\ 3& 3 & 3\end{pmatrix}$,
\item   $\begin{pmatrix}1&1&1 \\ 2&2&2 \\ 3& 3 & 3\end{pmatrix} \cdot \begin{pmatrix}1&0&0 \\ 0&2&0 \\ 0& 0 & 3\end{pmatrix}$.
\end{enumerate}
\end{ejercicio}

\begin{Shaded}
\begin{lstlisting}[language=Python]
# Usamos el comando diag para definir matrices diagonales
D = np.diag(np.array([1,2,3]))
print("D = \n", D)
print("D^2 = \n", D @ D)
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
%% D =
%%  [[1 0 0]
%%  [0 2 0]
%%  [0 0 3]]
%% D^2 =
%%  [[1 0 0]
%%  [0 4 0]
%%  [0 0 9]]
\end{verbatim}

\subsubsection{Matriz identidad}

Para cada $n \in \mathbb{N}$, la matriz $I_n \in \R^{n \times n}$ es la matriz diagonal con $a_{ii} = 1$ para todo $1 \le i \le n$ y $a_{ij} = 0$ para $i \ne j$, es decir:
$$
I_n =\begin{pmatrix}1&0&\cdots &0\\0&1&\cdots &0\\\vdots &\vdots &\ddots &\vdots \\0&0&\cdots &1\\\end{pmatrix}
$$

\begin{proposicion}
Para toda $\Bb \in \R^{n \times n}$ , $I_n \cdot \Bb = \Bb \cdot I_n = \Bb$.
\end{proposicion}

Podemos usar el comando \texttt{eye} de \texttt{numpy} para definir una matriz identidad.

\begin{Shaded}
\begin{lstlisting}[language=Python]
id = np.eye(3)

# Creamos una matriz de 3 x 3 con números aleatorios entre 0 y 1
A = np.random.rand(3,3)
print("A = \n", A)
print("id * A = \n", id @ A)
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
%% A =
%%  [[0.91836939 0.31101594 0.48474114]
%%  [0.00093026 0.37622722 0.91214465]
%%  [0.6293026  0.20801675 0.6855896 ]]
%% id * A =
%%  [[0.91836939 0.31101594 0.48474114]
%%  [0.00093026 0.37622722 0.91214465]
%%  [0.6293026  0.20801675 0.6855896 ]]
\end{verbatim}

\subsubsection{Mas Matrices especiales}

\begin{itemize}
\item \textbf{Triangular superior:} Una matriz $\Ub \in \R^{n \times n}$ se llama triangular superior si $a_{ij} = 0$ para todo $i > j$ (es decir, todas las entradas abajo de la diagonal son 0).
\item \textbf{Triangular inferior:} Una matriz $\Lb \in \R^{n \times n}$ se llama triangular inferior si $a_{ij} = 0$ para todo $i > j$ (es decir, para todas las entradas arriba de la diagonal son 0).
\item \textbf{Matriz simétrica:} $\Ab\in \R^{n\times n}$ es simétrica si $\Ab^T = \Ab$.
\item \textbf{Matriz Hermitiana:} $\Ab\in \C^{n\times n}$ es Hermitiana si $\Ab^* = \Ab$.
\item \textbf{Matriz ortogonal:} $\Ab$ es ortogonal si $\Ab\Ab^T = \Ab^T\Ab = \Id_n$.
\item \textbf{Matriz unitaria:} $\Ab\in \C^{n\times n}$ es unitaria si $\Ab\Ab^* = \Ab^*\Ab = \Id_n$.
\end{itemize}

    \subsubsection{Inversa de una matriz}

Dada una matriz $\Ab \in \R^{n \times n}$, si existe una matriz $\Bb \in \R^{n\times n}$ tal que
$$
\Ab\Bb = \Id_n = \Bb\Ab,
$$
decimos que $\Ab$ es inversible y $\Bb$ es la inversa de $\Ab$. Si $\Ab$ es inversible, la inversa es única y la notamos $\Ab^{-1}$. Si $\Ab$ no es inversible, decimos que $\Ab$ es singular.

Para calcular la inversa de una matriz podemos aplicar eliminación gaussiana, observando que encontrar una matriz $B$ tal que $\Ab \Bb = \Id_n$ es equivalente a resolver los $n$ sistemas de ecuaciones
$$
\Ab \begin{pmatrix} b_{1j} \\ b_{2j} \\ \vdots \\ b_{nj} \end{pmatrix} = \eb_j,
$$
donde $\eb_j$ es el $j$-ésimo vector canónico, que coinicide con la $j$-ésima columna de la matriz $\Id_n$.

\begin{ejemplo}
Calculamos la inversa de la matriz
$$
\Ab = \begin{pmatrix} 2 & 0 & -2 \\ 1 & -1 & 1 \\ 0 & 2 & 1\end{pmatrix}.
$$
Podemos resolver los sistemas $\Ab \bb_j = \eb_j$, $1 \le j \le 3$, simultáneamente considerando una matriz ampliada con los 3 vectores $\eb_j$ a la derecha:
$$
\left(\begin{array}{ccc|ccc} 2 & 0 & -2 & 1 & 0 & 0 \\ 1 & -1 & 1 & 0 & 1 & 0\\ 0 & 2 & 1 & 0 & 0 & 1\end{array}\right).
$$

\begin{Shaded}
\begin{lstlisting}[language=Python]
A = np.array([[1, 4, 3, -1,], [1, 0, 1, 0], [3, 3, 2, 7], [2, 6, 0, 14], [2, 3, 1, 7]])
print(row_echelon(A))
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
%% [[ 2.  0. -2.  1.  0.  0.]
%%  [ 1. -1.  1.  0.  1.  0.]
%%  [ 0.  2.  1.  0.  0.  1.]]
%% Matriz escalonada:
%%  [[ 1.   0.  -1.   0.5  0.   0. ]
%%  [ 0.   1.  -2.   0.5 -1.  -0. ]
%%  [ 0.   0.   1.  -0.2  0.4  0.2]]
\end{verbatim}

La función \texttt{row\_echelon} que estamos utilizando coloca 1's como primer elemento no nulo de cada fila, dividiendo cada fila por el escalar apropiado.

A partir de la matriz escalonada podemos ahora encontrar fácilmente las casillas $b_{ij}$ de $\Bb$. Por ejemplo, la última fila será $[-0.2 0.4 0.2]$. Para las filas anteriores, podemos realizar ahora la triangulación hacia arriba:
$$
\left(\begin{array}{ccc|ccc}
 1. &  0. & -1. &  0.5 &  0.  &  0.  \\
 0. &  1. & -2. &  0.5 & -1.  & 0.  \\
 0. &  0. &  1. & -0.2 &  0.4 &  0.2 \\
\end{array}\right)
\xrightarrow{\substack{f_2 + 2f_3 \rightarrow f_2 \\ f_1 + f_3 \rightarrow f_1}}
\left(\begin{array}{ccc|ccc}
 1. &  0. & 0. &  0.5 &  0.4  &  0.2  \\
 0. &  1. & 0. &  0.5 & 0.2  & 0.4.  \\
 0. &  0. &  1. & -0.2 &  0.4 &  0.2 \\
 \end{array}\right).
$$

Ahora la matriz que estamos buscando es exactamente la matriz formada por las últimas 3 columnas de la matriz ampliada.
$$
\Bb = \begin{pmatrix}
 0.3 &  0.4  &  0.2  \\
 0.1 & 0.2  & 0.4.  \\
 -0.2 &  0.4 &  0.2 \\
\end{pmatrix}.
$$

Lo verificamos en \python.

\begin{Shaded}
\begin{lstlisting}[language=Python]
B = np.array([[0.3, 0.4, 0.2], [0.1, -0.2, 0.4], [-0.2, 0.4, 0.2]])
print(A @ B)
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
%% [[ 1.00000000e+00  0.00000000e+00  0.00000000e+00]
%%  [-2.77555756e-17  1.00000000e+00  0.00000000e+00]
%%  [ 0.00000000e+00  0.00000000e+00  1.00000000e+00]]
\end{verbatim}

\end{ejemplo}

\begin{aplicacion}
Si $\Ab \in \R^{n \times n}$ es inversible, la solución del sistema
$$
\Ab\xb = \bb
$$
es $\xb = \Ab^{-1}\bb$.
\end{aplicacion}

Para calcular la inversa en \python usamos el comando \texttt{inv} del paquete \texttt{numpy.linalg} (o podemos usar el comando \texttt{solve} del mismo paquete para resolver la ecuación matricial $\Ab\Xb = \Id_n$).

\begin{Shaded}
\begin{lstlisting}[language=Python]
# Probando...
A = np.array([[1,7],[2,3]])
print("A = \n", A)

A_inv = np.linalg.inv(A)
print("A^(-1) = \n", A_inv)

print("A * A^(-1) = \n", A @ A_inv)

print("La solución de AX = Id_2 es")
print(np.linalg.solve(A, np.eye(2)))
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
## A =
##  [[1 7]
##  [2 3]]
## A^(-1) =
##  [[-0.27272727  0.63636364]
##  [ 0.18181818 -0.09090909]]
## A * A^(-1) =
##  [[1. 0.]
##  [0. 1.]]
## La solución de AX = Id_2 es
##  [[-0.27272727  0.63636364]
##  [ 0.18181818 -0.09090909]]
\end{verbatim}
\textbf{Nota:} En la práctica, es mejor resolver un sistema por eliminación gaussiana que invirtiendo la matriz.

\subsubsection{Traza de una matriz}

La traza de una matriz \emph{cuadrada} es la suma de los elementos de la diagonal.

Si $\Ab = (a_{ij}) \in \R^{n \times n}$, $\tr(\Ab) = a_{11} + a_{22} + \dots + a_{nn} = \sum_{i=1}^n a_{ii}$ .

\begin{proposicion} Si $\Ab, \Bb \in \R^{n \times n}$:
\begin{itemize}
\item $\tr(\Ab^T)=\tr(\Ab)$
\item $\tr(\Ab+\Bb) = \tr(\Ab) + \tr(\Bb)$.
\end{itemize}
\end{proposicion}

Calculamos la traza en \python con el comando \texttt{trace} de \texttt{numpy}.

\begin{Shaded}
\begin{lstlisting}[language=Python]
A = np.array([[1,5,1],[-6,7,8],[0,9,-2]])
print("A = \n", A)
print("Traza de A = ", tr(A)
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
%% A =
%%  [[ 1  5  1]
%%  [-6  7  8]
%%  [ 0  9 -2]]
%% Traza de A =  6
\end{verbatim}

\subsection{Determinante de una matriz}

El determinante de una matriz \emph{cuadrada} se puede definir recursivamente por la siguiente fórmula

$$
\det(\Ab)= \begin{cases}
a_{11} & \text{si } n = 1 \\
\sum _{j=1}^{n}(-1)^{i+j}a_{ij} \det(\Mb_{ij}) & \text{si } n > 1,
\end{cases}
$$
donde $\Mb_{ij}$ es la matrix de $(n-1) \times (n-1)$ que se obtiene al eliminar la fila $i$ y la columna $j$ de $\Ab$.

\begin{ejemplo}\leavevmode
\begin{enumerate}
\item $\det\begin{pmatrix} a & b \\ c & d \end{pmatrix} = ad - bc$
\item $\det\begin{pmatrix} 1 & 2 & 3 \\ 3 & 0 & 7 \\ 0 & -1 & 4 \end{pmatrix} = \det\begin{pmatrix} 0 & 7 \\ -1 & 4 \end{pmatrix} - 3 \det\begin{pmatrix} 2 & 3 \\ -1 & 4 \end{pmatrix} = 7 - 3 \cdot 11=-26$
\end{enumerate}
\end{ejemplo}

\begin{proposicion} Si $\Ab \in  \R^{n \times n}$ y $f_i$, $1 \le i \le n$, son las filas de $\Ab$, las siguientes operaciones en la matriz modifican el determinante:
\begin{itemize}
\item transponer la matriz: $\det(\Ab^T) = \det(\Ab)$
\item multiplicar una fila por un escalar: $\det\begin{pmatrix} \text{---} & f_1 & \text{---}\\ & \vdots & \\ \text{---} & f_{i-1} & \text{---}\\ \text{---} & \alpha f_i & \text{---}\\ \text{---} & f_{i+1} & \text{---} \\ & \vdots & \\ \text{---} & f_n  & \text{---}\end{pmatrix} = \alpha \det(A)$
\item sumar un múltiplo de una fila a otra fila: $\det\begin{pmatrix} \text{---} & f_1 & \text{---}\\ & \vdots & \\ \text{---} & f_{i-1} & \text{---}\\ \text{---} & f_i + \beta f_j & \text{---}\\ \text{---} & f_{i+1} & \text{---} \\ & \vdots & \\ \text{---} & f_n  & \text{---}\end{pmatrix} = \det(A)$
\item intercambiar dos filas: $\det\begin{pmatrix} \text{---} & f_1   & \text{---}\\ & \vdots   & \\ \text{---} & f_{i}   & \text{---}\\ & \vdots & \\ \text{---} & f_{j}   & \text{---}\\  & \vdots   & \\ \text{---} & f_n   & \text{---} \end{pmatrix} = - \det\begin{pmatrix} \text{---} & f_1   & \text{---}\\ & \vdots   & \\ \text{---} & f_{j}   & \text{---}\\ & \vdots & \\ \text{---} & f_{i}   & \text{---}\\  & \vdots   & \\ \text{---} & f_n   & \text{---} \end{pmatrix}$
\item multiplicar toda la matriz por un escalar: $\det(k\Ab)=k^n \det(\Ab)$, para $k \in \R$.
\item multiplicar toda la matriz por $(-1)$: $\det(-\Ab)=(-1)^n \det(\Ab)$.
\end{itemize}
\end{proposicion}

En base a esta propiedad podemos demostrar f\'acilmente las siguientes propiedades.

\begin{corolario}\leavevmode
\begin{itemize}
\item Si $\Ab$ tiene dos filas iguales, $\det(\Ab)= 0$.
\item Si $\Ab$ tiene una fila de ceros, $\det(\Ab)= 0$.
\item $\det(\Ab) = 0$ si y solo si $\Ab$ es singular.
\end{itemize}
\end{corolario}

\begin{proposicion}
Si $\Ab, \Bb \in \R^{n \times n}$,
$$\det(\Ab \Bb) = \det(\Ab)\det(\Bb).$$
\end{proposicion}

Calculamos determinantes en \python con el comando \texttt{det} de \texttt{numpy.linalg}.
\begin{Shaded}
\begin{lstlisting}[language=python]
A = np.array([[1,5,0],[-1,-3,8],[0,1,-2]])
B = np.array([[0,4,2],[2,6,1],[1,5,-1]])
print("det(A) = ", np.linalg.det(A));
print("det(B) = ", np.linalg.det(B));
print("det(AB) = ", np.linalg.det(A @ B));

# No hay relación con los determinantes de A y B
print("det(A + B) = ", np.linalg.det(A + B));

M = np.array([[1,2,3],[4,5,6],[7,8,9]])
print("det(M) = ", np.linalg.det(M));
\end{lstlisting}
\end{Shaded}

\begin{verbatim}
%% det(A) =  -12.0
%% det(B) =  19.999999999999996
%% det(AB) =  -240.0000000000002
%% det(A + B) =  51.0
%% det(M) =  -9.51619735392994e-16
\end{verbatim}

\begin{ejercicio}
Para $\Ab = \begin{pmatrix} 3 & 2 & -1 \\ 3 & 0 & 7 \\ 0 & -1 & 4 \end{pmatrix}$ , probar que el sistema $\Ab\xb = \bb$ tiene solución única para todo $\bb \in \R^3$
\end{ejercicio}

\subsubsection{Determinante de una matriz triangular superior o inferior}

Si $\Ab \in \R^{n \times n}$ es triangular inferior o superior su determinante es igual al producto de los elementos de la diagonal.

$$
\det\begin{pmatrix}a_{11}&a_{12}&\cdots & a_{1n} \\ 0 &a_{22}&\cdots & a_{2n}\\\vdots &\vdots &\ddots &\vdots \\0&0 & \cdots &a_{nn}\\\end{pmatrix} = \det\begin{pmatrix}a_{11}& 0&\cdots &0 \\ a_{21} &a_{22}&\cdots & 0\\\vdots &\vdots &\ddots &\vdots \\a_{n1}&a_{n2} & \cdots &a_{nn}\\\end{pmatrix} = \prod_{i=1}^n a_{ii}
$$




\section{Cambio de base}

Dado un espacio vectorial $V$ de dimensión $n$ llamamos base canónica de $V$ al conjunto $\E= \{\eb_1, \dots, \eb_n\}$ de vectores canónicos, $\eb_i(j) = \begin{cases} 1 & \text{ si } i = j \\ 0 & \text{ si } i \neq j \end{cases}$, donde $\eb_i(j)$ es la $j$-ésima coordenada del vector $\eb_i$.

Dada otra base $\B$ de $V$, queremos saber cómo escribir en la base $\B$ a un vector $\vb$ del cual conocemos sus coordenadas en la base $\E$. Y viceversa, cómo escribir en la base canónica a un vector del cual conocemos sus coordenadas en la base $\B$.

\subsubsection{Cambio de base de $\B$ a $\E$}

Analizamos un ejemplo. Consideramos la base de $\R^3$
$$\B= \{(1,2,5), (0, 1, 7), (0,0,-1)\}$$  y el vector
$$\vb = (3, -2, 1)_\B.$$

Para averiguar las coordenadas de $\vb$ en la base canónica, hacemos la cuenta
$$\vb = 3 (1,2,5) + (-2) (0, 1, 7) + 1 (0, 0, -1) = (3, 4, 0)$$
(en general omitimos el subíndice $\E$ cuando escribimos un vector en las coordenadas de la base canónica).

Podemos escribirlo matricialmente:
$$
\vb = \begin{pmatrix}
1 & 0 & 0 \\
2 & 1 & 0 \\
5 & 7 & -1\end{pmatrix} \begin{pmatrix} 3 \\ -2 \\ -1 \end{pmatrix} =  \begin{pmatrix} 3 \\ 4 \\ 0 \end{pmatrix}.
$$
Observamos que la matriz $\begin{pmatrix} 1 & 0 & 0 \\ 2 & 1 & 0 \\ 5 & 7 & -1 \end{pmatrix}$ posee los vectores de $\B$ como columnas y es la matriz que nos permite pasar un vector en coordenadas de una base $\B$ a la base canónica. Llamamos $\Cb_{\B\E}$ a esta matriz. Obtenemos
$$
\vb_\E= \Cb_{\B\E} \vb_\B.
$$

\begin{ejercicio}\leavevmode
\begin{enumerate}
 \item Dada la base $\B = \{(1,3,7), (4, 0, 1), (5, -7, 0)\}$ de $\R^3$ y el vector $\vb$ de $\R^3$ de coordenadas $(1,2,-5)$ en la base $\B$, hallar las coordenadas de $\vb$ en la base canónica.
\item Dada la base $\B = \{1, (x-1), (x-1)^2\}$ de $\R[x]_2$ y el polinomio $p(x)$ de coordenadas $(7, -2, 1)$ en la base $\B$, hallar las coordenadas de $p$ en la base canónica de $\R[x]_2$. Observar que esto equivale a escribir como suma de potencias de $x$ a un polinomio que viene dado como suma de potencias de $(x-1)$.
\end{enumerate}
\end{ejercicio}

\subsubsection{Cambio de base de $\B$ a $\E$}

Ahora queremos escribir a $\vb = (3,7, -1)_\E$ en la base $\B$. Para esto, necesitamos resolver el sistema de ecuaciones $$
(3, 7, -1) = \sum_{i=1}^{3} a_i b_i = a_1 (1,2,5) + a_2 (0, 1, 7) + a_3 (0,0,-1)
$$ Esto nos da un sistema de 3 ecuaciones y 3 incógnitas, que podemos plantear en forma matricial:
$$
\begin{pmatrix}
1 & 0 & 0 \\
2 & 1 & 0 \\
5 & 7 & -1
\end{pmatrix} \begin{pmatrix} a_1 \\ a_2 \\a_3 \end{pmatrix}  = \begin{pmatrix} 3 \\ 7 \\ -1 \end{pmatrix}.
$$

Observamos que la matriz $\begin{pmatrix} 1 & 0 & 0 \\ 2 & 1 & 0 \\ 5 & 7 & -1 \end{pmatrix}$ de coeficientes posee los vectores de $\B$ como columnas, es decir, es la matriz $\Cb_{\B\E}$. Como $\B$ es una base, la matriz $\Cb_{\B\E}$ es inversible (¿por qué?).

Por lo tanto,
$$
 \begin{pmatrix} a_1 \\ a_2 \\a_3 \end{pmatrix}  = \begin{pmatrix}
1 & 0 & 0 \\
2 & 1 & 0 \\
5 & 7 & -1
\end{pmatrix}^{-1} \begin{pmatrix} 3 \\ 7 \\ -1 \end{pmatrix} = (\Cb_{\B\E})^{-1} \begin{pmatrix} 3 \\ 7 \\ -1 \end{pmatrix}.
$$

Obtenemos que la matriz de cambio de base de la base canónica $\E$ a una base $\B$ es $\Cb_{\E\B} = \Cb_{\B\E}$.

%```{r}
%C_BE = matrix(c(1,0,0,2,1,0,5,7,-1), nrow = 3, byrow=TRUE)
%C_EB = solve(C_BE)
%\vb = c(3,7,-1)
%\vb_B = C_EB %*% \vb   # El vector en la base B
%print(\vb_B)
%
%# Podemos convertir nuevamente a la base canónica
%print(C_BE %*% \vb_B)
%
%```

{\bf En resumen:}
Tenemos una base $\B=\{b_1, \dots, b_n\}$ de un espacio vectorial $V$ de dimensión $n$.

\begin{enumerate}
\item Construimos la matriz $\Cb_{\B\E} = \begin{pmatrix} \mid & \mid & & \mid \\ {\bb}_{1} & {\bb}_{2} & \cdots & {\bb}_{n}\\ \mid & \mid & & \mid \\ \end{pmatrix}$.
\item Para pasar un vector en base $\B$ a base canónica, usamos $\vb_\E= \Cb_{\B\E} \vb_\B$.
\item Para pasar un vector en base base canónica a la base $\B$, definimos $\Cb_{\E\B} = (\Cb_{\B\E})^{-1}$ y usamos $\vb_\B= \Cb_{\E\B} \vb_\E$.
\end{enumerate} 